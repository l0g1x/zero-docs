---
title: Basic Concepts
---

Zero applications have three primary schema components:

1. **Tables and Columns**: The traditional backend database schema that defines your tables, columns, and relationships. This is what you define in your database (e.g., Postgres) and is used by Zero to understand your data structure.

2. **Relationships**: First-class definitions of how tables are connected to each other. These relationships enable powerful querying capabilities and type-safe joins in ZQL.

3. **Permissions**: A separate schema that defines access control rules for your data. This determines who can read, write, or modify specific tables and rows in your database.

The Zero schema combines these three aspects to:

1. Provide typesafety for ZQL queries
2. Define first-class relationships between tables
3. Define permissions for access control

<Note
  type="note"
  slug="generating"
  heading="You do not need to define the Zero schema by hand"
>
  [Community-contributed converters](./generators) exist for Prisma and Drizzle
  that generate the tables and relationships. While these generators make it
  easy to get started, understanding how Zero schemas work is valuable for: -
  Debugging type and relationship issues - Understanding how Zero maps your data
  model - Customizing generated schemas when needed - Troubleshooting permission
  and access control problems
</Note>

## Schema Usage

The Zero schema is used in three key places:

1. **Zero Client**: The schema is required when initializing a Zero client instance (i.e. inside a React provider). It provides type safety and relationship information for queries and mutations.

2. **Zero Cache Server**: The schema is used by the `zero-cache` server to validate and process client requests, ensuring data consistency and proper relationship handling.

3. **Permissions Deployment**: When deploying permissions using `npx zero-deploy-permissions`, the schema is used to validate and apply permission changes. This is needed when:

   - The core database schema has been modified
   - Only the permissions schema has been changed
   - You need to update existing permissions

In all cases, the schema file location is specified using the `ZERO_SCHEMA_PATH` environment variable.

## Defining the Zero Schema

The Zero schema is encoded in a TypeScript file that is conventionally called `schema.ts` file. For example, see [the schema file for`hello-zero`](https://github.com/rocicorp/hello-zero/blob/main/src/schema.ts).

## Database Schemas

Use `createSchema` to define the entire Zero schema:

```tsx
import {createSchema} from '@rocicorp/zero';

export const schema = createSchema({
  tables: [user, medium, message],
  relationships: [userRelationships, mediumRelationships, messageRelationships],
});
```

## Migrations

Zero uses TypeScript-style structural typing to detect schema changes and implement smooth migrations.

### How it Works

When the Zero client connects to `zero-cache` it sends a copy of the schema it was constructed with. `zero-cache` compares this schema to the one it has, and rejects the connection with a special error code if the schema is incompatible.

By default, The Zero client handles this error code by calling `location.reload()`. The intent is to to get a newer version of the app that has been updated to handle the new server schema.

<Note type="note" heading="Update Order">
  It's important to update the database schema first, then the app. Otherwise a reload loop will occur.

If a reload loop does occur, Zero uses exponential backoff to avoid overloading the server.

</Note>

If you want to delay this reload, you can do so by providing the `onUpdateNeeded` constructor parameter:

```ts
const z = new Zero({
  onUpdateNeeded: updateReason => {
    if (reason.type === 'SchemaVersionNotSupported') {
      // Do something custom here, like show a banner.
      // When you're ready, call `location.reload()`.
    }
  },
});
```

If the schema changes while a client is running in a compatible way, `zero-cache` syncs the schema change to the client so that it's ready when the app reloads and gets new code that needs it. If the schema changes while a client is running in an incompatible way, `zero-cache` will close the client connection with the same error code as above.

### Schema Change Process

Like other database-backed applications, Zero schema migration generally follow an "expand/migrate/contract" pattern:

1. Implement and run an "expand" migration on the backend that is backwards compatible with existing schemas. Add new rows, tables, as well as any defaults and triggers needed for backwards compatibility.
2. Add any new permissions required for the new tables/columns by running [`zero-deploy-permissions`](/docs/permissions#permission-deployment).
3. Update and deploy the client app to use the new schema.
4. Optionally, after some grace period, implement and run a "contract" migration on the backend, deleting any obsolete rows/tables.

Steps 1-3 can generally be done as part of one deploy by your CI pipeline, but step 4 would be weeks later when most open clients have refreshed and gotten new code.

<Note
  type="warning"
  slug="postgres-special-cases"
  heading="Postgres Special Cases"
>
  Certain schema changes require special handling in Postgres. See [Schema
  Changes](/docs/postgres-support#schema-changes) for details.
</Note>
