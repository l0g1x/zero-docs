---
title: Defining Relationships
---

Relationships in Zero define how tables are connected to each other. They enable powerful querying capabilities and type-safe joins in ZQL. This guide covers how to define and use relationships effectively.

## Relationship Types

Zero supports four main types of relationships:

1. **One-to-One**: A single record in one table relates to a single record in another table
2. **One-to-Many**: A single record in one table relates to multiple records in another table
3. **Many-to-One**: Multiple records in one table relate to a single record in another table
4. **Many-to-Many**: Multiple records in one table relate to multiple records in another table

## Basic Relationship Definition

Use the `relationships` function to define relationships between tables. The `one` and `many` helpers define singular and plural relationships, respectively:

```ts
const messageRelationships = relationships(message, ({one, many}) => ({
  sender: one({
    sourceField: ['senderID'],
    destField: ['id'],
    destSchema: user,
  }),
  replies: many({
    sourceField: ['id'],
    destSchema: message,
    destField: ['parentMessageID'],
  }),
}));
```

This creates "sender" and "replies" relationships that can be queried with the [`related` ZQL clause](./reading-data#relationships):

```ts
const messagesWithSenderAndReplies = z.query.messages
  .related('sender')
  .related('replies');
```

Each message will have a `sender` field that is a single `User` object or `null`, and a `replies` field that is an array of `Message` objects.

## Relationship Configuration

<Note type="note" heading="Schema Generation">
  You don't need to define relationships manually. Community-contributed
  converters exist for [Prisma](./generators#prisma) and
  [Drizzle](./generators#drizzle) that generate the relationships automatically
  from your existing schema definitions.
</Note>

Relationships are configured using three main properties:

- `sourceField`: The field(s) in the source table that reference the destination table
- `destField`: The field(s) in the destination table that are referenced
- `destSchema`: The schema of the destination table

### Field Configuration

Fields can be single or compound:

```ts
// Single field relationship
const simpleRelationship = one({
  sourceField: ['userId'],
  destField: ['id'],
  destSchema: user,
});

// Compound field relationship
const compoundRelationship = one({
  sourceField: ['orgId', 'userId'],
  destField: ['orgId', 'id'],
  destSchema: user,
});
```

## Many-to-Many Relationships

Many-to-many relationships require a junction table and are defined by chaining relationship definitions:

```ts
const issueRelationships = relationships(issue, ({many}) => ({
  labels: many(
    {
      sourceField: ['id'],
      destSchema: issueLabel,
      destField: ['issueID'],
    },
    {
      sourceField: ['labelID'],
      destSchema: label,
      destField: ['id'],
    },
  ),
}));
```

<Note type="warning" slug="chain-limit" heading="Chain Limit">
  Currently only two levels of chaining are supported for `relationships`. See
  https://bugs.rocicorp.dev/issue/3454.
</Note>

## Compound Keys Relationships

Relationships can traverse compound keys. For example, a `user` table with a compound primary key of `orgID` and `userID`:

```ts
const messageRelationships = relationships(message, ({one}) => ({
  sender: one({
    sourceField: ['senderOrgID', 'senderUserID'],
    destSchema: user,
    destField: ['orgID', 'userID'],
  }),
}));
```

## Circular Relationships

Circular relationships (self-referential relationships) are fully supported:

```tsx
const commentRelationships = relationships(comment, ({one}) => ({
  parent: one({
    sourceField: ['parentID'],
    destSchema: comment,
    destField: ['id'],
  }),
}));
```

## Relationship Querying

Relationships can be queried using the `related` clause in ZQL. You can:

1. Query single relationships:

```ts
const messagesWithSender = z.query.messages.related('sender');
```

2. Query nested relationships:

```ts
const messagesWithSenderAndOrg = z.query.messages
  .related('sender')
  .related('sender.organization');
```

3. Filter by related fields:

```ts
const messagesFromAdmin = z.query.messages
  .related('sender')
  .where('sender.role', '=', 'admin');
```

## Best Practices

1. **Naming Conventions**

   - Use singular names for `one` relationships (e.g., `sender`, `parent`)
   - Use plural names for `many` relationships (e.g., `replies`, `labels`)
   - Be consistent with your naming across the schema

2. **Performance Considerations**

   - Avoid deeply nested relationships in queries
   - Use appropriate indexes on relationship fields
   - Consider the impact of relationship queries on your database

3. **Type Safety**
   - Zero provides full type safety for relationship queries
   - Use TypeScript to catch relationship errors at compile time
   - Leverage IDE autocompletion for relationship fields

## Migration Considerations

When modifying relationships:

1. Add new relationships in an "expand" migration
2. Update the Zero schema to include new relationships
3. Deploy the updated schema
4. Remove old relationships in a "contract" migration

<Note type="warning" heading="Breaking Changes">
  Changing relationship types (e.g., from `one` to `many`) is a breaking change
  and requires careful migration planning.
</Note>

## Common Issues

1. **Missing Fields**: Ensure all referenced fields exist in both source and destination tables
2. **Type Mismatches**: Field types must match between source and destination
3. **Circular Dependencies**: Be careful with circular relationships to avoid infinite loops
4. **Null Handling**: Consider how null values in relationship fields affect your queries

For more information about querying relationships, see the [Reading Data](/docs/reading-data#relationships) documentation.
